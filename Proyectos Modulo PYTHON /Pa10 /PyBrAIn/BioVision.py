# -*- coding: utf-8 -*-
"""BioVision_Colab_Notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wSddNdvvnQf6s15j5ISPHXKg8yCkSra

# **BioVisión —  Proyecto (SIC)**
**Prototipo analítico** que identifica factores de riesgo de **diabetes** y su relación con la **salud ocular** usando **Python (pandas + matplotlib)**.

> **Datasets:**  
> - `DiabetesPrediccion.csv` (clínico, mixto H/M)

## **Entorno y librerías**
"""

# Importar bibliotecas necesarias para el análisis de datos, visualización y modelado
import os # Para interactuar con el sistema operativo (no se usa directamente en este fragmento, pero es común)
import math # Funciones matemáticas (no se usa directamente en este fragmento)
import numpy as np # Para operaciones numéricas y arrays
import pandas as pd # Para manipulación y análisis de datos (DataFrames)
import matplotlib.pyplot as plt # Para crear visualizaciones estáticas
import seaborn as sns # Basado en matplotlib, para visualizaciones estadísticas más atractivas

# Módulos de scikit-learn para el modelo de regresión logística
from sklearn.linear_model import LogisticRegression # Modelo lineal para clasificación
from sklearn.preprocessing import StandardScaler # Para escalar (normalizar) las características
from sklearn.model_selection import train_test_split # Para dividir el dataset en conjuntos de entrenamiento y prueba
from sklearn.metrics import classification_report # Para evaluar el rendimiento del modelo

"""
## **Cargar datasets**"""

# Cargar el dataset clínico desde un archivo CSV
clin = pd.read_csv("DiabetesPrediccion.csv")  # DataFrame con datos clínicos

# Mostrar las primeras 3 filas del DataFrame para una inspección rápida
display(clin.head(3))

"""## **Inspección rápida**"""

# Información general del dataset
clin.info()

# Resumen estadístico de las variables numéricas
display(clin.describe().T)

# Porcentaje de valores nulos
print("Valores nulos por columna (%):")
print(clin.isna().mean().round(3) * 100)

"""
## **Limpieza y normalización**
- Estandarizar **edad** y **sexo** en ambos datasets.  
- En ocular: crear `has_retinopathy = D` (0/1).  
- En clínico: asegurar `diabetes` (0/1), y numéricos válidos (`bmi`, `HbA1c_level`, `blood_glucose_level`).
- Filtrar edades fuera de rango razonable (0–110).
"""

# Creamos una copia del dataset original para trabajar
data = clin.copy()

# Normalizamos el texto en la columna 'gender' (género)
data['gender'] = data['gender'].str.upper().str.strip()

# Convertimos columnas a numéricas, tratando errores como NaN
for col in ['age','bmi','HbA1c_level','blood_glucose_level']:
    data[col] = pd.to_numeric(data[col], errors='coerce')

# Filtramos filas donde la edad está fuera de un rango razonable (0 a 110 años)
data = data[(data['age']>0) & (data['age']<=110)]

# Renombramos la columna 'diabetes' a 'has_diabetes' y la convertimos a entero (0 o 1)
data['has_diabetes'] = data['diabetes'].astype(int)

# Imprimimos las dimensiones del dataset limpio
print("Dataset limpio:", data.shape)
# Mostramos las primeras filas del dataset limpio
display(data.head())

"""
## **Binning de edad y agregación (agrupacion)**
Creamos grupos etarios: `≤30, 31–40, 41–50, 51–60, 61–70, 70+` y calculamos **prevalencias** por **edad × sexo**.

"""

# Definimos los rangos para agrupar las edades
bins = [0, 30, 40, 50, 60, 70, 110]
# Definimos las etiquetas para cada rango de edad
labels = ['≤30', '31–40', '41–50', '51–60', '61–70', '>70']
# Creamos una nueva columna 'age_bin' que contiene el grupo de edad al que pertenece cada individuo
data['age_bin'] = pd.cut(data['age'], bins=bins, labels=labels, right=True)

# Agrupamos los datos por grupo de edad y género
age_sex_grp = (
    data.groupby(['age_bin','gender'])
      # Calculamos el número total de individuos en cada grupo ('count')
      .agg(count=('age','size'),
           # Calculamos la suma de casos de diabetes en cada grupo ('sum')
           sum=('diabetes','sum'))
      # Calculamos la tasa de diabetes (proporción de casos) por grupo
      .assign(rate_diabetes=lambda x: x['sum']/x['count'])
      # Reseteamos el índice para que 'age_bin' y 'gender' vuelvan a ser columnas
      .reset_index()
)

"""## **Creación de grupos de edad y análisis de prevalencia**
En esta sección, agruparemos a los individuos por rangos de edad definidos para analizar la prevalencia de diabetes dentro de cada grupo, separando los resultados por género. Esto nos permitirá identificar patrones en la distribución de la diabetes según la edad y el sexo.

Creamos los siguientes grupos etarios: `≤30, 31–40, 41–50, 51–60, 61–70, 70+`. Luego, calcularemos la proporción de casos de diabetes por cada combinación de grupo de edad y género.

## **Visualizaciones clave**
A continuación, generaremos gráficos para visualizar las relaciones entre diferentes variables y la prevalencia de diabetes.

1. **Tasa de Diabetes por Grupo de Edad y Género:** Este gráfico de barras mostrará cómo varía la proporción de personas con diabetes a través de los diferentes grupos de edad, diferenciando entre hombres y mujeres. Esto nos ayudará a entender el impacto de la edad y el género en el riesgo de diabetes.

## **Visualizaciones base**  
1. Diabetes por edad (M/F).
"""

# Creamos una tabla pivote para preparar los datos para la visualización
# El índice son los grupos de edad, las columnas son los géneros y los valores son las tasas de diabetes
pivot = age_sex_grp.pivot(index='age_bin', columns='gender', values='rate_diabetes')

# Creamos un gráfico de barras a partir de la tabla pivote
pivot.plot(kind='bar', figsize=(8,5))

# Configuramos el título y las etiquetas de los ejes
plt.title('Tasa de Diabetes por Grupo de Edad y Género')
plt.ylabel('Proporción de casos de diabetes')
plt.xlabel('Grupo de Edad')
# Mostramos la leyenda del gráfico
plt.legend(title='Género')
# Añadimos una cuadrícula horizontal para facilitar la lectura
plt.grid(axis='y', alpha=0.3)
# Ajustamos el layout para evitar que las etiquetas se solapen
plt.tight_layout()
# Mostramos el gráfico
plt.show()

corr = data[['age','bmi','HbA1c_level','blood_glucose_level','hypertension','heart_disease','diabetes']].corr()
corr['diabetes'].sort_values(ascending=False)

sns.barplot(x='gender', y='hypertension', data=data, estimator=lambda x: sum(x)/len(x))
plt.title('Proporción de hipertensos por género')
plt.ylabel('Proporción')
plt.show()

sns.barplot(x='gender', y='heart_disease', data=data, estimator=lambda x: sum(x)/len(x))
plt.title('Proporción de cardiopatías por género')
plt.ylabel('Proporción')
plt.show()

num_cols = ['age','bmi','HbA1c_level','blood_glucose_level','hypertension','heart_disease','diabetes']
corr = data[num_cols].corr()

plt.figure(figsize=(8,6))
sns.heatmap(corr, annot=True, fmt='.2f', cmap='coolwarm', square=True)
plt.title('Matriz de correlaciones clínicas')
plt.show()

pivot = age_sex_grp.pivot(index='age_bin', columns='gender', values='rate_diabetes')
pivot.plot(kind='bar', figsize=(8,5))
plt.title('Tasa de Diabetes por Grupo de Edad y Género')
plt.ylabel('Proporción de casos de diabetes')
plt.xlabel('Grupo de Edad')
plt.legend(title='Género')
plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.show()

# Seleccionamos las variables predictoras (características) para el modelo
X = data[['age','bmi','HbA1c_level','blood_glucose_level','hypertension','heart_disease']]
# Seleccionamos la variable objetivo (lo que queremos predecir)
y = data['diabetes']

# Inicializamos el escalador para normalizar las características
scaler = StandardScaler()
# Ajustamos el escalador a los datos y transformamos las características
X_scaled = scaler.fit_transform(X)

# Dividimos los datos en conjuntos de entrenamiento y prueba (70% entrenamiento, 30% prueba)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Inicializamos el modelo de regresión logística
model = LogisticRegression()
# Entrenamos el modelo con los datos de entrenamiento
model.fit(X_train, y_train)

# Creamos un DataFrame para mostrar los coeficientes del modelo
# Estos coeficientes indican la importancia de cada variable en la predicción
coefs = pd.DataFrame({'Variable': X.columns, 'Coeficiente': model.coef_[0]})
# Ordenamos los coeficientes de mayor a menor para ver qué variables tienen más peso
display(coefs.sort_values('Coeficiente', ascending=False))

col_bmi = "bmi_clipped" if "bmi_clipped" in data.columns else "bmi"

# Preparamos los datos para el gráfico:
df_age_bmi = (data
              # Creamos una nueva columna 'diabetes_label' para poner etiquetas amigables
              .assign(diabetes_label=lambda d: np.where(d["diabetes"].astype(int)==1, "Con diabetes", "Sin diabetes"))
              # Agrupamos por grupo de edad y la nueva etiqueta de diabetes
              .groupby(["age_bin","diabetes_label"], as_index=False)[col_bmi]
              # Calculamos el promedio de IMC para cada grupo
              .mean())

# Creamos el gráfico de barras
plt.figure(figsize=(8,5)) # Definimos el tamaño del gráfico
sns.barplot(data=df_age_bmi, x="age_bin", y=col_bmi, hue="diabetes_label", errorbar=None) # Creamos el gráfico de barras
plt.title("IMC promedio por grupo de edad y condición de diabetes") # Título del gráfico
plt.xlabel("Grupo de edad") # Etiqueta del eje X
plt.ylabel("IMC promedio") # Etiqueta del eje Y
plt.legend(title="Condición") # Mostramos la leyenda (Con/Sin diabetes)
plt.tight_layout() # Ajustamos el diseño para que no se solapen los elementos
plt.show() # Mostramos el gráfico

# --- Copia del DataFrame ---
# Creamos una copia del DataFrame original para no modificar los datos brutos
df_plot = data.copy()

# Aseguramos que la columna 'diabetes' sea numérica (0 o 1) y llenamos posibles valores nulos con 0
df_plot["diabetes"] = pd.to_numeric(df_plot["diabetes"], errors="coerce").fillna(0).astype(int)

# Creamos una nueva columna 'diabetes_label' para tener etiquetas de texto más amigables
df_plot["diabetes_label"] = np.where(df_plot["diabetes"] == 1, "Con diabetes", "Sin diabetes")

# --- Gráfico de Densidad (KDE Plot) ---
# Configuramos el tamaño de la figura para el gráfico
plt.figure(figsize=(8,5))
# Creamos el gráfico de densidad para la columna 'blood_glucose_level'
sns.kdeplot(
    data=df_plot, # Usamos el DataFrame copiado
    x="blood_glucose_level", # Eje x: nivel de glucosa en sangre
    hue="diabetes_label", # Diferenciamos las curvas por si tienen diabetes o no
    fill=True, # Rellenamos el área bajo las curvas
    common_norm=False, # Normalizamos cada curva independientemente
    alpha=0.35, # Hacemos las áreas un poco transparentes
    linewidth=2, # Grosor de la línea de la curva
    palette={"Sin diabetes": "#1f77b4", "Con diabetes": "#ff7f0e"}, # Definimos los colores
    hue_order=["Sin diabetes", "Con diabetes"] # Establecemos el orden de las etiquetas en la leyenda
)

# --- Configuraciones del Gráfico ---
plt.title("Distribución del nivel de glucosa (Curva de densidad)", fontsize=12) # Título del gráfico
plt.xlabel("Nivel de glucosa (mg/dL)", fontsize=11) # Etiqueta del eje x
plt.ylabel("Densidad de frecuencia", fontsize=11) # Etiqueta del eje y
plt.legend(title="Condición", loc="upper right") # Mostramos la leyenda con un título
plt.grid(alpha=0.3) # Añadimos una cuadrícula semi-transparente
plt.tight_layout() # Ajustamos el layout para que no se solapen los elementos
plt.show() # Mostramos el gráfico

# DataFrame con las variables y sus coeficientes obtenidos del modelo de regresión logística
coef_data = pd.DataFrame({
    'Variable': ['HbA1c_level', 'blood_glucose_level', 'age', 'bmi', 'hypertension', 'heart_disease'],
    'Coeficiente': [2.508315, 1.364603, 1.045791, 0.589105, 0.202218, 0.151952]
})

# Ordenar las variables por su coeficiente de mayor a menor para visualizar su importancia
coef_data = coef_data.sort_values('Coeficiente', ascending=True)

# --- Creación del Gráfico de Barras Horizontales ---
plt.figure(figsize=(7,4.5)) # Define el tamaño de la figura para el gráfico
sns.barplot(data=coef_data, x='Coeficiente', y='Variable', palette='coolwarm') # Crea el gráfico de barras
plt.title('Importancia de las variables predictoras del riesgo de diabetes') # Establece el título del gráfico
plt.xlabel('Peso en el modelo (Coeficiente)') # Etiqueta el eje x
plt.ylabel('Variable') # Etiqueta el eje y
plt.grid(axis='x', alpha=0.3) # Añade una cuadrícula horizontal semi-transparente
plt.tight_layout() # Ajusta el layout para evitar solapamientos
plt.show() # Muestra el gráfico